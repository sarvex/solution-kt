internal class Solution {
  private var p: IntArray
  private var size: IntArray
  fun minMalwareSpread(graph: Array<IntArray>, initial: IntArray): Int {
    val n = graph.size
    p = IntArray(n)
    size = IntArray(n)
    for (i in 0 until n) {
      p[i] = i
      size[i] = 1
    }
    val clean = BooleanArray(n)
    Arrays.fill(clean, true)
    for (i in initial) {
      clean[i] = false
    }
    for (i in 0 until n) {
      if (!clean[i]) {
        continue
      }
      for (j in i + 1 until n) {
        if (clean[j] && graph[i][j] == 1) {
          union(i, j)
        }
      }
    }
    val cnt = IntArray(n)
    val mp: Map<Int, Set<Int>> = HashMap()
    for (i in initial) {
      val s: Set<Int> = HashSet()
      for (j in 0 until n) {
        if (clean[j] && graph[i][j] == 1) {
          s.add(find(j))
        }
      }
      for (root in s) {
        cnt[root] += 1
      }
      mp.put(i, s)
    }
    var mx = -1
    var ans = 0
    for (entry in mp.entrySet()) {
      val i: Int = entry.getKey()
      var t = 0
      for (root in entry.getValue()) {
        if (cnt[root] == 1) {
          t += size[root]
        }
      }
      if (mx < t || mx == t && i < ans) {
        mx = t
        ans = i
      }
    }
    return ans
  }

  private fun find(x: Int): Int {
    if (p[x] != x) {
      p[x] = find(p[x])
    }
    return p[x]
  }

  private fun union(a: Int, b: Int) {
    val pa = find(a)
    val pb = find(b)
    if (pa != pb) {
      size[pb] += size[pa]
      p[pa] = pb
    }
  }
}
